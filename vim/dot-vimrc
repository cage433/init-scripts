set number        " always show line numbers
set nocompatible
set path=.,**,,
call pathogen#helptags()
call pathogen#runtime_append_all_bundles() 
let mapleader=","
nmap <silent> <leader>sv :w $MYVIMRC<CR>:so $MYVIMRC<CR>
nmap <silent> <leader>se :e $MYVIMRC<CR>
set hidden

set wrap        
set backspace=indent,eol,start " allow backspacing over everything in insert mode
set noautoindent    " always set autoindenting on
set copyindent    " copy the previous indentation on autoindenting
set shiftround    " use multiple of shiftwidth when indenting with '<' and '>'
set showmatch     " set show matching parenthesis
set ignorecase    " ignore case when searching
set smartcase     " ignore case if search pattern is all lowercase,  case-sensitive otherwise
set smarttab      " insert tabs on the start of a line according to shiftwidth, not tabstop
"set hlsearch      " highlight search terms
set incsearch     " show search matches as you type
set gdefault
set nobackup
set noswapfile
"set pastetoggle=<F4>
set nopaste
set lazyredraw
nnoremap ; :
nnoremap \ ;
vnoremap ; :
vnoremap \ ;
map <C-h> <C-w>h
map <C-j> <C-w>j
map <C-k> <C-w>k
map <C-l> <C-w>l
nmap <silent> ,/ :nohlsearch<CR>
nmap j gj
nmap k gk

map <F2> :set hlsearch!<CR>
function! SplitOrOnly()
  if winnr("$") == 1
    exec ":vs"
  else
    exec ":only"
  endif
endfunction
map <silent> <F10> :call SplitOrOnly()<CR>

function! TogglePaste()
  if &paste
    exec ":set nopaste"
    echo "Paste Off"
  else
    exec ":set paste"
    echo "Paste On"
  endif
endfunction
map <silent> <F4> :call TogglePaste()<CR>

map <silent> <F3> :call BufferList()<CR>
map <silent> <F6> :NERDTreeToggle<CR>
map <silent> <F1> <ESC>
imap <silent> <F1> <ESC>
set showmatch
set cpoptions-=m
nmap <C-p> ?^(<CR>
nmap <C-n> /^(<CR>
syntax enable
"syntax off
filetype plugin indent on
set autowrite
autocmd FileType scala setlocal shiftwidth=2 tabstop=2
autocmd FileType rb setlocal shiftwidth=2 tabstop=2
autocmd FileType c setlocal shiftwidth=4 tabstop=4
autocmd FileType cpp setlocal shiftwidth=4 tabstop=4


" Revert PWD to its original value
let g:initialdir = getcwd()
function! PutPwdBack()
	exec ":cd " . g:initialdir
endfunction

:set tabstop=2
:set shiftwidth=2
:set expandtab

:set gdefault

inoremap jj <ESC>
inoremap jk <ESC>o
inoremap kj <ESC>O

set encoding=utf-8
set scrolloff=3
set showmode
set showcmd
set hidden
set wildmenu
set wildmode=list:longest
set visualbell
set cursorline
set ttyfast
set ruler
set backspace=indent,eol,start
"set laststatus=
"set relativenumber
"set undofile

"Search recursively for tags file
set tags=tags;/

" CD to the current files directory
"


:set noignorecase
:set textwidth=0
function! SaveWinline()
  let g:currentwinline = winline()
endfunction

" Stops the buffer jumping around when adding imports
function! RestoreWinline()
  while winline() > g:currentwinline
    exec "normal \<C-e>"
  endwhile
  while winline() < g:currentwinline
    exec "normal \<C-y>"
  endwhile
endfunction

function! SplitScreenIfNecessary()
  if winnr() == 1
    exec ":silent only"
    exec ":vs"
  endif
  exec "normal \<C-w>w"
endfunction

function! OutputDateAndSwitchBuffer()
  exec ":silent r ! date"
  w
  exec "normal gg"
  exec "normal \<C-w>w"
endfunction

function! TargetDirectory(scalafile)
  let path = split(a:scalafile, "/")
  while ! empty(path)
    let candidate_target = "/".join(path, "/")."/target"
    if isdirectory(candidate_target)
      return candidate_target
    endif
    call remove(path, -1)
  endwhile
  return ""
endfunction!

function! CompileThisFile()
  let scalafile = expand("%:p")
  if stridx(scalafile, "tests") == -1
    let last_dir = "classes/"
  else
    let last_dir = "test-classes/"
  endif
  let target_dir = TargetDirectory(scalafile)
  if target_dir == ""
    echo "Target dir not found"
    return
  endif
  let classdir = target_dir . "/scala_2.9.0-1/" . last_dir
  w
  call SplitScreenIfNecessary()
  exec ":silent vi ~/tmp/starling_comp"
  exec ":silent normal ggdG"
  exec ":silent r ! date"
  exec ":silent r ! /usr/local/scala/bin/fsc -deprecation -d " . classdir . " " . scalafile . " | cat"
  call OutputDateAndSwitchBuffer()
endfunction

map  <leader>l :call CompileThisFile()<CR>

function! StarlingPackage(scalafile)
  let path = reverse(split(a:scalafile, "/"))
  let idx = index(path, "starling")
  let package_path = path[1:idx]
  return join(reverse(package_path), ".")
endfunction

function! RunATest(scalafile, classname)
  let g:lasttestfile = a:scalafile
  let g:lastclassname = a:classname
  let pkg = StarlingPackage(a:scalafile)
  let fullclassname = pkg . "." . a:classname
  w
  call SplitScreenIfNecessary()
  exec ":silent vi ~/tmp/starling_test"
  exec ":silent normal ggdG"
  exec ":silent r ! date"
  if stridx(fullclassname, "Test") == -1
    exec ":silent r ! /usr/local/bin/scala " . fullclassname
  else
    "echo ":silent r ! /usr/local/scala/bin/scala org.scalatest.tools.Runner -p . -oNCOHL -s " . fullclassname
    exec ":silent r ! /usr/local/scala/bin/scala org.scalatest.tools.Runner -p . -oNCOHL -s " . fullclassname
  endif

  call OutputDateAndSwitchBuffer()
endfunction

function! RunThisTest() 
  call RunATest(expand("%:p"), expand("%:t:r"))
endfunction

function! RunLastTest()
  call RunATest(g:lasttestfile, g:lastclassname)
endfunction

function! ToggleSourceAndTestFile()
  exec ":vi " . TestOrSourceFile()
endfunction


function! ToggleSourceAndTestFileOtherWindow()
  let otherfile = TestOrSourceFile()
  call SplitScreenIfNecessary()
  exec ":vi " . otherfile
endfunction

function! TestOrSourceFile()
  if stridx(expand("%"), "Tests.scala") == -1
    return substitute(expand("%:r"), "\/src\/", "/tests/", "") . "Tests.scala" 
    "return substitute(expand("%:r"), "\/main\/", "/test/", "") . "Tests.scala" 
  else 
    let otherfile = substitute(expand("%:r"), "\/tests\/", "/src/", "")
    "let otherfile = substitute(expand("%:r"), "\/test\/", "/main/", "")
    return substitute(otherfile, "Tests", "", "") . ".scala"
  endif
endfunction

function! OpenTagInOtherWindow()
  let tag = expand("<cword>")
  call SplitScreenIfNecessary()
  exec ":tag " . tag
endfunction
function! InsertClassName()
  let name = expand("%:t:r")
  exe "normal a".name
  redraw!
endfunction


function! TidyScalaImports()
  let scalafile = expand("%")
  "exec ":silent ~/tidy-imports.rb ".shellescape(expand("%"))
  exec ":%d"
  exec ":silent r ! ".shellescape(expand("~/bin/tidy-imports.rb"))." ".shellescape(expand("%:p"))
  exec ":normal ggdd"
  exec ":w"
  "system("~/tidy-imports.rb ".shellescape(expand("%")))
endfunction

function! SwitchNumbering()
  if &relativenumber
    set norelativenumber
    set number
  elseif &number
    set norelativenumber
    set nonumber
  else
    set nonumber
    set relativenumber
  end
endfunction
map <F9> :call SwitchNumbering()<CR>
map <leader>Q :call TidyScalaImports()<CR>
imap <F5> println("Debug: <Esc>:call InsertClassName()<CR>a: " + )<Esc>i

map <leader>t :call ToggleSourceAndTestFile()<CR>
map <leader>T :call ToggleSourceAndTestFileOtherWindow()<CR>

map <leader>k :call RunThisTest()<CR>
map <leader>j :call RunLastTest()<CR>
map <leader>J :call CompileThisFile()<CR>:call RunLastTest()<CR>

map <leader>w :call OpenTagInOtherWindow()<CR>,/

" Lisp comment/uncomment
map <leader>; :s /^/\/\/ /<CR>
map <leader>: :s /^\/\/ //<CR>

" Change PWD to that of the current file
map <silent> <leader>c :cd %:h<CR>

" And put it back
map <leader>d :call PutPwdBack()<CR>

" comment and uncomment
map <leader>m mb:.,'as/^/\/\/<CR>,/'b
map <leader>n mb:.,'as/^\/\///g<CR>,/'b

"show starling imports
map <leader>i ma:r ! find_imports.rb <cword><CR>`a

" show all imports
map <leader>o ma:r ! find_imports.rb <cword> -a<CR>`a

"Show sub classes
map <leader>s ma:r ! find_subtypes.rb <cword><CR>`a

"Put the selected import line at the top and delete any others
map <leader>u ma?^[^i]<CR>mb:call SaveWinline()<CR>'ayy'b?^i<CR>p'b:.,$g/^import/d<CR>'b,/:call RestoreWinline()<CR>

" Add first import
map <leader>I <leader>ij<leader>u

"jump to parent class
map <leader>p ?extends<CR>w<C-]>

" Wipe buffer without deleting window
map <leader>z :BW<CR>

"Comment out all tests except this
map <leader>x :call SaveWinline()<CR>ma?@Test<CR>mb:0,-1s/@Test/\/\/@Test/e<CR>'b:+1,$s/@Test/\/\/@Test/e<CR>'a:call RestoreWinline()<CR>,/
map <silent> <leader>X ma:call SaveWinline()<CR>:%s/\/\/@Test/@Test<CR>'a:call RestoreWinline()<CR>,/

"Switch between tabs
" map  <leader>L :tabnext<CR>
" map  <leader>H :tabprevious<CR>

iab pfl printf("File %s, line %d\n", __FILE__, __LINE__);
" set paste

set exrc

function! ExtractJars()
	silent! g/\[INFO]/d
	silent! s/\:/\r/
"	silent! %s/\(\.\|\w\|\/\|-\)\+\//
endfunction

map <leader>q :call ExtractJars()<CR>

function! GetDepsFn()
  silent! g!/dependency/d
  silent! g!/trafigura/d
  silent! %s/.\+class /
  silent! %s/'.\+$/
endfunction

command! GetDeps call GetDepsFn()

map <leader>gr :Gtags -r <C-r>=expand("<cword>")<CR><CR>
