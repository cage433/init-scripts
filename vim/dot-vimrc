let g:relative_test_class_dir="/test-classes/"
let g:scalatest_reporter=""
let g:orientation="landscape"
let g:show_test_exceptions=0
if filereadable(".lvimrc")
  execute "source .lvimrc"
endif

set laststatus=2

set timeoutlen=600
"set number        " always show line numbers
set nocompatible
set path=.,**,,
call pathogen#helptags()
call pathogen#runtime_append_all_bundles() 
let mapleader=","

nmap <silent> <leader>sv :source $MYVIMRC<CR>
nmap <silent> <leader>se :e $MYVIMRC<CR>
set hidden

set wrap        
set backspace=indent,eol,start " allow backspacing over everything in insert mode
set autoindent    " always set autoindenting on
set copyindent    " copy the previous indentation on autoindenting
set shiftround    " use multiple of shiftwidth when indenting with '<' and '>'
set showmatch     " set show matching parenthesis
"set ignorecase    " ignore case when searching
set smartcase     " ignore case if search pattern is all lowercase,  case-sensitive otherwise
set smarttab      " insert tabs on the start of a line according to shiftwidth, not tabstop
set incsearch     " show search matches as you type
set gdefault
set nobackup
set noswapfile
set nopaste
set lazyredraw
nnoremap ; :
nnoremap <leader>m ;
vnoremap ; :
vnoremap <leader>m ;
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l
nnoremap <leader>a :cope <CR><C-w>k
nmap <silent> ,/ :nohlsearch<CR>
nmap j gj
nmap k gk
nnoremap <M-l> :vertical resize +5<CR>
map <F2> :set hlsearch!<CR>
function! SplitOrOnly()
  if winnr("$") == 1
    if g:orientation == "landscape"
      exec ":vsplit"
    else
      exec ":split"
    end
  else
    exec ":only"
  endif
endfunction
map <silent> <F10> :call SplitOrOnly()<CR>

function! TogglePaste()
  if &paste
    exec ":set nopaste"
    echo "Paste Off"
  else
    exec ":set paste"
    echo "Paste On"
  endif
endfunction
map <silent> <F4> :call TogglePaste()<CR>

map <silent> <F3> :call BufferList()<CR>
map <silent> <F1> <ESC>
imap <silent> <F1> <ESC>
inoremap jk <ESC>
set showmatch
set cpoptions-=m
nmap <C-p> ?^(<CR>
nmap <C-n> /^(<CR>
syntax enable
function! ToggleSyntax()
  if exists("g:syntax_on") 
   syntax off 
"set nohlsearch
"set t_Co=0
 else 
   syntax enable 
 endif 
endfunction
noremap <F7> :call ToggleSyntax()<CR>

filetype plugin indent on
syntax on
set autowrite
autocmd FileType scala setlocal shiftwidth=2 tabstop=2
autocmd FileType scala ab -> →
autocmd FileType scala ab => ⇒
autocmd FileType rb setlocal shiftwidth=2 tabstop=2
autocmd FileType c setlocal shiftwidth=4 tabstop=4
autocmd FileType cpp setlocal shiftwidth=4 tabstop=4
"autocmd FileType sh noremap <leader>m :w<CR> :! . % <CR>
autocmd FileType lisp set iskeyword+=-
autocmd FileType clojure set iskeyword+=-


" Revert PWD to its original value
let g:initialdir = getcwd()
function! PutPwdBack()
	exec ":cd " . g:initialdir
endfunction

:set tabstop=2
:set shiftwidth=2
:set expandtab

:set gdefault


set encoding=utf-8
set scrolloff=3
set showmode
set showcmd
set hidden
set wildmenu
set wildmode=list:longest
set visualbell
set cursorline
set ttyfast
set backspace=indent,eol,start

"Search recursively for tags file
set tags=tags;/

:set textwidth=0
function! SaveWinline()
  let g:currentwinline = winline()
endfunction

" Stops the buffer jumping around when adding imports
function! RestoreWinline()
  while winline() > g:currentwinline
    exec "normal \<C-e>"
  endwhile
  while winline() < g:currentwinline
    exec "normal \<C-y>"
  endwhile
endfunction

function! SplitScreenIfNecessary()
  if winnr("$") == 1
    exec ":silent only"
    exec ":vs"
  endif
  exec "normal \<C-w>w"
endfunction

function! OutputDateAndSwitchBuffer()
  exec ":silent r ! date"
  w
  exec "normal gg"
  exec "normal \<C-w>w"
endfunction

function! TryTargetDirectory(path, lastComponent, relativeTargetDir)
  if index(a:path, a:lastComponent) > -1
    call remove(a:path, index(a:path, a:lastComponent), len(a:path) - 1)
    return "/".join(a:path, "/").a:relativeTargetDir
  else 
    return ""
  endif
endfunction

function! TargetDirectory(scalafile)
  let path = split(a:scalafile, "/")
  let dir = TryTargetDirectory(path, "src", g:relative_class_dir)
  if dir == ""
    let dir = TryTargetDirectory(path, "tests", g:relative_test_class_dir)
  endif
  if dir == ""
    let dir = TryTargetDirectory(path, "test", g:relative_test_class_dir)
  endif
  if dir != "" && !isdirectory(dir)
    call mkdir(dir, "p")
  endif
  return dir
endfunction!


function! StarlingPackage(scalafile)
  let path = reverse(split(a:scalafile, "/"))
  let idx = index(path, "src")
  if idx == -1 
    let idx = index(path, "tests")
  endif
  let package_path = path[1:idx-1]
  return join(reverse(package_path), ".")
endfunction

function! ToggleTestExceptions()
  let g:show_test_exceptions = !g:show_test_exceptions
endfunction
map <leader>sx :call ToggleTestExceptions()<CR>

function! RunATest(scalafile, classname)
  echo "Trying to run test"
  let g:lasttestfile = a:scalafile
  let g:lastclassname = a:classname
  let pkg = StarlingPackage(a:scalafile)
  let fullclassname = pkg . "." . a:classname
  "w
  if (match(getline(1), '^\#!') == 0)
    :! clear;./%
  elseif stridx(fullclassname, "Test") == -1
    exec "! clear; /usr/local/scala/bin/scala $JAVA_OPTS " . fullclassname
  else
    if g:scalatest_reporter == ""
      let test_reporter_arg = ""
    else
      let test_reporter_arg =  " -C " . g:scalatest_reporter
    endif
    if g:show_test_exceptions
      let test_reporter_arg = test_reporter_arg." -R . -oFHL " 
    else
      let test_reporter_arg = test_reporter_arg." -R . -oHL " 
    endif

    "exec "! echo /usr/local/jdk/bin/java $JAVA_OPTS -Xmx2000m -XX:MaxPermSize=500m -Dmaker.home=. -Dlogback.configurationFile=logback-unit-tests.xml -Dsbt.log.format=false -Dscala.usejavacp=true org.scalatest.tools.Runner ".test_reporter_arg." -s " . fullclassname
    exec "! clear; /usr/local/jdk/bin/java $JAVA_OPTS -Xmx2000m -XX:MaxPermSize=500m -Dmaker.home=. -Dlogback.configurationFile=logback-unit-tests.xml -Dsbt.log.format=false -Dscala.usejavacp=true org.scalatest.tools.Runner ".test_reporter_arg." -s " . fullclassname
  endif

endfunction

function! RunThisTest() 
  call RunATest(expand("%:p"), expand("%:t:r"))
endfunction

function! RunLastTest()
  call RunATest(g:lasttestfile, g:lastclassname)
endfunction

function! ToggleSourceAndTestFile()
  let otherfile = TestOrSourceFile()
  if (CreateSourceDirectory(otherfile))
    if filereadable(otherfile) || input("Create file ".otherfile."? [y/N] ") == 'y'
      exec ":vi " . otherfile
    endif
  endif
endfunction

function! TestOrSourceFile()
  if stridx(expand("%"), "Tests.scala") == -1
    return substitute(expand("%:r"), "src\/", "tests/", "") . "Tests.scala" 
  else 
    let otherfile = substitute(expand("%"), "tests\/", "src/", "")
    return substitute(otherfile, "Tests\\.", ".", "")
  endif
endfunction

function! CreateSourceDirectory(sourceFile)
  let dir = fnamemodify(a:sourceFile, ":h")
  if !isdirectory(dir) && input("Make directory ".dir."? [y/N] ") == 'y'
    execute ':silent !mkdir -p '.dir
  endif
  return isdirectory(dir)
endfunction


function! ToggleRepo(useSplitIfExists)
  if exists('g:otherRepo')
    let otherfile = OtherRepoFile()
    if filereadable(otherfile)
      if winnr("$") > 1 && a:useSplitIfExists
        exec "normal \<C-w>w"
      endif
      exec ":vi " . otherfile
    else
      echo "File " . otherfile . " does not exist"
    endif
  else
    echo "Not configured to switch repos"
  endif
endfunction

function! OtherRepoFile()
  let absCurrentFile = expand("%:p")
  if stridx(absCurrentFile, g:otherRepo) == -1
    let relCurrentFileWithLeadingSlash = strpart(absCurrentFile, strlen(getcwd()))
    return g:otherRepo . relCurrentFileWithLeadingSlash
  else
    return strpart(absCurrentFile, strlen(g:otherRepo) + 1)
  endif
endfunction

map <leader>M :call ToggleRepo(0)<CR>
map <leader>N :call ToggleRepo(1)<CR>

function! OpenTagInOtherWindow()
  let tag = expand("<cword>")
  call SplitScreenIfNecessary()
  exec ":tag " . tag
endfunction
function! InsertClassName()
  let name = expand("%:t:r")
  exe "normal a".name
  redraw!
endfunction


function! TidyScalaImports()
  let scalafile = expand("%")
  exec ":%d"
  exec ":silent r ! ".shellescape("tidy-imports.rb")." ".shellescape(expand("%:p"))
  exec ":normal ggdd"
  exec ":w"
endfunction

command! R !./%
function! ExecCurrentBuffer()
  exec ":! ./%"
endfunction
map <leader>L :call ExecCurrentBuffer()<CR>

function! SwitchNumbering()
  if &relativenumber
    set norelativenumber
    set number
  elseif &number
    set norelativenumber
    set nonumber
  else
    set nonumber
    set relativenumber
  end
endfunction
map <F9> :call SwitchNumbering()<CR>

map <leader>Q :call TidyScalaImports()<CR>
imap <F5> println("Debug: <Esc>:call InsertClassName()<CR>a: " + )<Esc>i

map <F6> :CtrlPClearAllCaches<CR>

map <silent><leader>tt :call ToggleSourceAndTestFile()<CR>

nnoremap <leader><leader> <C-^>

map <leader>k :call RunThisTest()<CR>
map <leader>j :call RunLastTest()<CR>

map <leader>w :call OpenTagInOtherWindow()<CR>,/

" Lisp comment/uncomment
map <leader>; :s /^/\/\/ /<CR>
map <leader>: :s /^\/\/ //<CR>

" Change PWD to that of the current file
map <silent> <leader>c :cd %:h<CR>

" And put it back
map <leader>d :call PutPwdBack()<CR>

"show starling imports
map <leader>ii ma:r ! scala-imports.rb -p <cword><CR>`a

" show external imports
map <leader>io ma:r ! scala-imports.rb -e <cword><CR>`a

" show java doc
map <leader>J ma:r ! scala-imports.rb -j <cword><CR>`a
"
" show scala doc
map <leader>S ma:r ! scala-imports.rb -s <cword><CR>`a

"Show lisp doc
map <leader>L ma: ! ide/links.rb <cword><CR>`a

"Show sub classes
map <leader>s ma:r ! find_subtypes.rb <cword><CR>`a

"Put the selected import line at the top and delete any others
map <leader>iu ma?^[^i]<CR>mb:call SaveWinline()<CR>'ayy'b?\(\(^i\)\\|\(^p\)\)<CR>p'b:.,$g/^import/d<CR>'b,/:call RestoreWinline()<CR>

" Add first import
map <leader>I <leader>ij<leader>u

"jump to parent class
map <leader>p ?extends<CR>w<C-]>

" Wipe buffer without deleting window
map <leader>z :BW<CR>

"Comment out all testng tests except this
map <leader>tx :call SaveWinline()<CR>ma?@Test<CR>mb:0,-1s/@Test/\/\/@Test/e<CR>'b:+1,$s/@Test/\/\/@Test/e<CR>'a:call RestoreWinline()<CR>,/
map <silent> <leader>tX ma:call SaveWinline()<CR>:%s/\/\/@Test/@Test<CR>'a:call RestoreWinline()<CR>,/
"Comment out all scalatest tests except this
map <leader>tr :call SaveWinline()<CR>ma?test(<CR>mb:0,-1s/test(/ignore(/e<CR>'b:+1,$s/test(/ignore(/e<CR>'a:call RestoreWinline()<CR>,/
map <silent> <leader>tR ma:call SaveWinline()<CR>:%s/ignore(/test(<CR>'a:call RestoreWinline()<CR>,/

iab pfl printf("File %s, line %d\n", __FILE__, __LINE__);

set exrc

map <leader>gr :Gtags -r <C-r>=expand("<cword>")<CR><CR>
map <leader>ar :Ack -r <C-r>=expand("<cword>")<CR><CR>

function! WritePackage()
  let path = expand("%:h")
  let index = stridx(path, "src/", 0)
  if index == -1
    let index = stridx(path, "tests/", 0)
    if index == -1
      let package = ""
    else
      let package = substitute(strpart(path, index + 6), "/", ".", "g") 
    endif
  else
    let package = substitute(strpart(path, index + 4), "/", ".", "g") 
  endif
  let line = "package ".package
  exe "normal a".line."\r"
  redraw!
endfunction

nmap <silent> <leader>sp :call WritePackage()<CR>

inoremap <silent> <leader>sd <C-R>="println(\"".expand('%:t')." "<CR>

function! WriteCaseClass()
  let classname = expand("%:t:r")
  exe "normal icase class ".classname."(){\r}"
  exe "normal! k/(\r"
  redraw!
endfunction
nmap <silent> <leader>sc :call WriteCaseClass()<CR>


function! WriteTrait()
  let classname = expand("%:t:r")
  exe "normal itrait ".classname."{\r}"
  redraw!
endfunction
nmap <silent> <leader>st :call WriteTrait()<CR>

function! OpenApiURL(shortClass, apiType)
  exe "silent ! open-api-url.rb ".a:shortClass." ".a:apiType
  redraw!
endfunction
function! OpenScalaURL(shortClass)
  call OpenApiURL(a:shortClass, "s")
endfunction
function! OpenJavaURL(shortClass)
  call OpenApiURL(a:shortClass, "j")
endfunction

map <leader>ss :silent :call OpenScalaURL(expand("<cword>"))<CR>
map <leader>sj :silent :call OpenJavaURL(expand("<cword>"))<CR>

"set efm=[error]\ %f:%l:%m
set efm=[error]\ %f:%l:%m
"set efm=%f:%l:\ error:%m
nnoremap <leader>ee :cfile vim-compile-output<CR>:copen<CR><CR>
nnoremap <leader>en :cn<CR>
nnoremap <leader>ep :cp<CR>



function! RefreshTags()
    exec "silent ! scala-tags.sh"
    redraw!
endfunction
command! RefreshCTags call RefreshTags()
map <leader>ct :silent :call RefreshTags()<CR>

set wildignore+=*.class

let g:CommandTMaxHeight=5
set ruler
set rulerformat=%55(%{strftime('%a\ %b\ %e\ %I:%M\ %p')}\ %5l,%-6(%c%V%)\ %P%)


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" MULTIPURPOSE TAB KEY
" Indent if we're at the beginning of a line. Else, do completion.
" Taken from https://github.com/garybernhardt/dotfiles
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
function! InsertTabWrapper()
    let col = col('.') - 1
    if !col || getline('.')[col - 1] !~ '\k'
        return "\<tab>"
    else
        return "\<c-p>"
    endif
endfunction
inoremap <tab> <c-r>=InsertTabWrapper()<cr>
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" RENAME CURRENT FILE
" Taken from https://github.com/garybernhardt/dotfiles
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
function! RenameFile()
    let old_name = expand('%')
    let new_name = input('New file name: ', expand('%'), 'file')
    if new_name != '' && new_name != old_name
        exec ':saveas ' . new_name
        exec ':silent !rm ' . old_name
        redraw!
    endif
endfunction
map <leader>n :call RenameFile()<cr>
inoremap <s-tab> <c-n>

let g:ackprg="ack-grep --type=noxml -H --nocolor --nogroup --column"

set runtimepath^=~/.vim/bundle/ctrlp.vim
let g:ctrlp_map = ',f'
let g:ctrlp_working_path_mode = 0
let g:ctrlp_by_filename = 1
let g:ctrlp_dotfiles = 0
let g:ctrlp_custom_ignore = '\.git$\|\.xml$'
set wildignore+=*.jar

set smartcase

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" CREATE PARENT DIRECTORIES ON SAVE
" taken from http://stackoverflow.com/questions/4292733/vim-creating-parent-directories-on-save
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
augroup BWCCreateDir
    au!
    autocmd BufWritePre * if expand("<afile>")!~#'^\w\+:/' && !isdirectory(expand("%:h")) | execute "silent! !mkdir -p ".shellescape(expand('%:h'), 1) | redraw! | endif
augroup END



"""""""""""""""""""""""""
" vim-slime
""""""""""""""""""""""""
let g:slime_target = "tmux"
let g:slime_paste_file = tempname()

"""""""""""""""""""""""
" paredit
""""""""""""""""""""""

let g:paredit_leader='\'
let g:paredit_shortmaps=1
let g:slimv_leader = '\'


highlight DiffAdd term=reverse cterm=bold ctermbg=green ctermfg=white 
highlight DiffChange term=reverse cterm=bold ctermbg=cyan ctermfg=black 
highlight DiffText term=reverse cterm=bold ctermbg=gray ctermfg=black 
highlight DiffDelete term=reverse cterm=bold ctermbg=red ctermfg=black 

"vimdiff current vs git head (fugitive extension)
nnoremap <leader>gd :Gdiff<cr> 
"switch back to current file and closes fugitive buffer
nnoremap <leader>gD :diffoff!<cr><c-w>h:bd<cr>
set t_Co=16
set background=dark
let g:solarized_termtrans=1
colorscheme solarized

