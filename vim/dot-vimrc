let g:relative_class_dir="/target/scala_2.9.1/classes/"
let g:relative_test_class_dir="/target/scala_2.9.1/test-classes/"
let g:scalatest_reporter="starling.utils.StarlingTestReporter"
if filereadable(".lvimrc")
  execute "source .lvimrc"
endif

set timeoutlen=600
set number        " always show line numbers
set nocompatible
set path=.,**,,
call pathogen#helptags()
call pathogen#runtime_append_all_bundles() 
let mapleader=","
nmap <silent> <leader>sv :so $MYVIMRC<CR>
nmap <silent> <leader>se :e $MYVIMRC<CR>
set hidden

set wrap        
set backspace=indent,eol,start " allow backspacing over everything in insert mode
set noautoindent    " always set autoindenting on
set copyindent    " copy the previous indentation on autoindenting
set shiftround    " use multiple of shiftwidth when indenting with '<' and '>'
set showmatch     " set show matching parenthesis
"set ignorecase    " ignore case when searching
set smartcase     " ignore case if search pattern is all lowercase,  case-sensitive otherwise
set smarttab      " insert tabs on the start of a line according to shiftwidth, not tabstop
set incsearch     " show search matches as you type
set gdefault
set nobackup
set noswapfile
set nopaste
set lazyredraw
nnoremap ; :
nnoremap \ ;
vnoremap ; :
vnoremap \ ;
map <C-h> <C-w>h
map <C-j> <C-w>j
map <C-k> <C-w>k
map <C-l> <C-w>l
nmap <silent> ,/ :nohlsearch<CR>
nmap j gj
nmap k gk

map <F2> :set hlsearch!<CR>
function! SplitOrOnly()
  if winnr("$") == 1
    exec ":vs"
  else
    exec ":only"
  endif
endfunction
map <silent> <F10> :call SplitOrOnly()<CR>

function! TogglePaste()
  if &paste
    exec ":set nopaste"
    echo "Paste Off"
  else
    exec ":set paste"
    echo "Paste On"
  endif
endfunction
map <silent> <F4> :call TogglePaste()<CR>

map <silent> <F3> :call BufferList()<CR>
map <silent> <F6> :NERDTreeToggle<CR>
map <silent> <F1> <ESC>
imap <silent> <F1> <ESC>
set showmatch
set cpoptions-=m
nmap <C-p> ?^(<CR>
nmap <C-n> /^(<CR>
syntax enable
filetype plugin indent on
set autowrite
autocmd FileType scala setlocal shiftwidth=2 tabstop=2
autocmd FileType scala ab -> →
autocmd FileType scala ab => ⇒
autocmd FileType rb setlocal shiftwidth=2 tabstop=2
autocmd FileType c setlocal shiftwidth=4 tabstop=4
autocmd FileType cpp setlocal shiftwidth=4 tabstop=4
autocmd FileType sh noremap <leader>m :w<CR> :! % <CR>


" Revert PWD to its original value
let g:initialdir = getcwd()
function! PutPwdBack()
	exec ":cd " . g:initialdir
endfunction

:set tabstop=2
:set shiftwidth=2
:set expandtab

:set gdefault

inoremap jk <ESC>

set encoding=utf-8
set scrolloff=3
set showmode
set showcmd
set hidden
set wildmenu
set wildmode=list:longest
set visualbell
set cursorline
set ttyfast
set ruler
set backspace=indent,eol,start
"set laststatus=
"set relativenumber
"set undofile

"Search recursively for tags file
set tags=tags;/

" CD to the current files directory
"


":set noignorecase
:set textwidth=0
function! SaveWinline()
  let g:currentwinline = winline()
endfunction

" Stops the buffer jumping around when adding imports
function! RestoreWinline()
  while winline() > g:currentwinline
    exec "normal \<C-e>"
  endwhile
  while winline() < g:currentwinline
    exec "normal \<C-y>"
  endwhile
endfunction

function! SplitScreenIfNecessary()
  if winnr() == 1
    exec ":silent only"
    exec ":vs"
  endif
  exec "normal \<C-w>w"
endfunction

function! OutputDateAndSwitchBuffer()
  exec ":silent r ! date"
  w
  exec "normal gg"
  exec "normal \<C-w>w"
endfunction

function! TryTargetDirectory(path, lastComponent, relativeTargetDir)
  if index(a:path, a:lastComponent) > -1
    call remove(a:path, index(a:path, a:lastComponent), len(a:path) - 1)
    return "/".join(a:path, "/").a:relativeTargetDir
  else 
    return ""
  endif
endfunction

function! TargetDirectory(scalafile)
  let path = split(a:scalafile, "/")
  let dir = TryTargetDirectory(path, "src", g:relative_class_dir)
  if dir == ""
    let dir = TryTargetDirectory(path, "tests", g:relative_test_class_dir)
  endif
  if dir == ""
    let dir = TryTargetDirectory(path, "test", g:relative_test_class_dir)
  endif
  if dir != "" && !isdirectory(dir)
    call mkdir(dir, "p")
  endif
  return dir
endfunction!


function! CompileThisFile()
  let scalafile = expand("%:p")
  let target_dir = TargetDirectory(scalafile)
  if target_dir == ""
    echo "Target dir not found"
    return
  endif
  w
  exec "! clear; time /usr/local/scala/bin/fsc -sourcepath src:tests -deprecation -d " . target_dir . " " . scalafile . " | cat | tee vim-compile-output"
endfunction

map  <leader>l :call CompileThisFile()<CR>

function! StarlingPackage(scalafile)
  let path = reverse(split(a:scalafile, "/"))
  let idx = index(path, "src")
  if idx == -1 
    let idx = index(path, "tests")
  endif
  let package_path = path[1:idx-1]
  return join(reverse(package_path), ".")
endfunction

function! RunATest(scalafile, classname)
  let g:lasttestfile = a:scalafile
  let g:lastclassname = a:classname
  let pkg = StarlingPackage(a:scalafile)
  let fullclassname = pkg . "." . a:classname
  w
  if stridx(fullclassname, "Test") == -1
    exec "! clear; /usr/local/scala/bin/scala " . fullclassname
  else
    if g:scalatest_reporter == ""
      let test_reporter_arg = ""
    else
      let test_reporter_arg =  " -r " . g:scalatest_reporter
    endif
    exec "! clear; /usr/local/scala/bin/scala org.scalatest.tools.Runner ".test_reporter_arg." -p . -oNCOHL -s " . fullclassname
  endif

  "call OutputDateAndSwitchBuffer()
endfunction

function! RunThisTest() 
  call RunATest(expand("%:p"), expand("%:t:r"))
endfunction

function! RunLastTest()
  call RunATest(g:lasttestfile, g:lastclassname)
endfunction

function! ToggleSourceAndTestFile()
  exec ":vi " . TestOrSourceFile()
endfunction


function! ToggleSourceAndTestFileOtherWindow()
  let otherfile = TestOrSourceFile()
  call SplitScreenIfNecessary()
  exec ":vi " . otherfile
endfunction

function! TestOrSourceFile()
  if stridx(expand("%"), "Tests.scala") == -1
    return substitute(expand("%:r"), "src\/", "tests/", "") . "Tests.scala" 
  else 
    let otherfile = substitute(expand("%:r"), "tests\/", "src/", "")
    return substitute(otherfile, "Tests", "", "") . ".scala"
  endif
endfunction

function! OpenTagInOtherWindow()
  let tag = expand("<cword>")
  call SplitScreenIfNecessary()
  exec ":tag " . tag
endfunction
function! InsertClassName()
  let name = expand("%:t:r")
  exe "normal a".name
  redraw!
endfunction


function! TidyScalaImports()
  let scalafile = expand("%")
  "exec ":silent ~/tidy-imports.rb ".shellescape(expand("%"))
  exec ":%d"
  exec ":silent r ! ".shellescape(expand("~/bin/tidy-imports.rb"))." ".shellescape(expand("%:p"))
  exec ":normal ggdd"
  exec ":w"
  "system("~/tidy-imports.rb ".shellescape(expand("%")))
endfunction

function! SwitchNumbering()
  if &relativenumber
    set norelativenumber
    set number
  elseif &number
    set norelativenumber
    set nonumber
  else
    set nonumber
    set relativenumber
  end
endfunction
map <F9> :call SwitchNumbering()<CR>
map <leader>Q :call TidyScalaImports()<CR>
imap <F5> println("Debug: <Esc>:call InsertClassName()<CR>a: " + )<Esc>i

map <leader>t :call ToggleSourceAndTestFile()<CR>
map <leader>T :call ToggleSourceAndTestFileOtherWindow()<CR>

nnoremap <silent> <leader>f :CommandT<CR>
nnoremap <leader><leader> <C-^>

map <leader>k :call RunThisTest()<CR>
map <leader>j :call RunLastTest()<CR>
map <leader>J :call CompileThisFile()<CR>:call RunLastTest()<CR>

map <leader>w :call OpenTagInOtherWindow()<CR>,/

" Lisp comment/uncomment
map <leader>; :s /^/\/\/ /<CR>
map <leader>: :s /^\/\/ //<CR>

" Change PWD to that of the current file
map <silent> <leader>c :cd %:h<CR>

" And put it back
map <leader>d :call PutPwdBack()<CR>

" comment and uncomment
"map <leader>m mb:.,'as/^/\/\/<CR>,/'b
"map <leader>n mb:.,'as/^\/\///g<CR>,/'b

"show starling imports
map <leader>i ma:r ! find_imports.rb <cword><CR>`a

" show all imports
map <leader>o ma:r ! find_imports.rb <cword> -a<CR>`a

"Show sub classes
map <leader>s ma:r ! find_subtypes.rb <cword><CR>`a

"Put the selected import line at the top and delete any others
"map <leader>u ma?^[^i]<CR>mb:call SaveWinline()<CR>'ayy'b?^i<CR>p'b:.,$g/^import/d<CR>'b,/:call RestoreWinline()<CR>
map <leader>u ma?^[^i]<CR>mb:call SaveWinline()<CR>'ayy'b?\(\(^i\)\\|\(^p\)\)<CR>p'b:.,$g/^import/d<CR>'b,/:call RestoreWinline()<CR>

" Add first import
map <leader>I <leader>ij<leader>u

"jump to parent class
map <leader>p ?extends<CR>w<C-]>

" Wipe buffer without deleting window
map <leader>z :BW<CR>

"Comment out all tests except this
map <leader>x :call SaveWinline()<CR>ma?@Test<CR>mb:0,-1s/@Test/\/\/@Test/e<CR>'b:+1,$s/@Test/\/\/@Test/e<CR>'a:call RestoreWinline()<CR>,/
map <silent> <leader>X ma:call SaveWinline()<CR>:%s/\/\/@Test/@Test<CR>'a:call RestoreWinline()<CR>,/

"Switch between tabs
" map  <leader>L :tabnext<CR>
" map  <leader>H :tabprevious<CR>

iab pfl printf("File %s, line %d\n", __FILE__, __LINE__);

set exrc

function! ExtractJars()
	silent! g/\[INFO]/d
	silent! s/\:/\r/
"	silent! %s/\(\.\|\w\|\/\|-\)\+\//
endfunction

map <leader>q :call ExtractJars()<CR>

function! GetDepsFn()
  silent! g!/dependency/d
  silent! g!/trafigura/d
  silent! %s/.\+class /
  silent! %s/'.\+$/
endfunction

command! GetDeps call GetDepsFn()

map <leader>gr :Gtags -r <C-r>=expand("<cword>")<CR><CR>

function! WritePackage()
  let path = expand("%:h")
  let index = stridx(path, "src/", 0)
  if index == -1
    let index = stridx(path, "tests/", 0)
    if index == -1
      let package = ""
    else
      let package = substitute(strpart(path, index + 6), "/", ".", "") 
    endif
  else
    let package = substitute(strpart(path, index + 4), "/", ".", "") 
  endif
  let line = "package ".package
  exe "normal a".line."\r"
  redraw!
endfunction

nmap <silent> <leader>sp :call WritePackage()<CR>

function! WriteCaseClass()
  let classname = expand("%:t:r")
  exe "normal icase class ".classname."(){\r}"
  exe "normal! k/(\r"
  redraw!
endfunction
nmap <silent> <leader>sc :call WriteCaseClass()<CR>


function! WriteTrait()
  let classname = expand("%:t:r")
  exe "normal itrait ".classname."{\r}"
  redraw!
endfunction
nmap <silent> <leader>st :call WriteTrait()<CR>

function! OpenApiURL(shortClass, apiType)
  exe "silent ! open-api-url.rb ".a:shortClass." ".a:apiType
  redraw!
endfunction
function! OpenScalaURL(shortClass)
  call OpenApiURL(a:shortClass, "s")
endfunction
function! OpenJavaURL(shortClass)
  call OpenApiURL(a:shortClass, "j")
endfunction

map <leader>ss :silent :call OpenScalaURL(expand("<cword>"))<CR>
map <leader>sj :silent :call OpenJavaURL(expand("<cword>"))<CR>

set makeprg=sbt/sbt\ compile
"set efm=%E\ %#[error]\ %f:%l:\ %m,%C\ %#[error]\ %p^,%-C%.%#,%Z,
"       \%W\ %#[warn]\ %f:%l:\ %m,%C\ %#[warn]\ %p^,%-C%.%#,%Z,
"       \%-G%.%#
"set efm=[error]\ %f:%l:\ %m
set efm=%f:%l:\ error%m
nnoremap <leader>ee :cfile vim-compile-output<CR>
nnoremap <leader>en :cn<CR>
nnoremap <leader>ep :cp<CR>



function! RefreshCTags()
    exec "silent ! ctags -R ."
    redraw!
endfunction
command! RefreshCTags call RefreshCTags()
map <leader>ct :silent :call RefreshCTags()<CR>

set wildignore+=*.class

let g:CommandTMaxHeight=5
set ruler
set rulerformat=%55(%{strftime('%a\ %b\ %e\ %I:%M\ %p')}\ %5l,%-6(%c%V%)\ %P%)


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" MULTIPURPOSE TAB KEY
" Indent if we're at the beginning of a line. Else, do completion.
" Taken from https://github.com/garybernhardt/dotfiles
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
function! InsertTabWrapper()
    let col = col('.') - 1
    if !col || getline('.')[col - 1] !~ '\k'
        return "\<tab>"
    else
        return "\<c-p>"
    endif
endfunction
inoremap <tab> <c-r>=InsertTabWrapper()<cr>
inoremap <s-tab> <c-n>
